CNN
Conv2D
입력 #(batch_size, rows, columns, channels) 4차원
출력 4차원

model.add(Conv2D(7, (2,2), input_shape=(8,8,1)))
(batch_size, rows, columns, channels)
(kernal_size + bias)*input*output
(2*2+1)*1*7

Conv1D
입력 3차원 출력 3차원
시계열 데이터에 주로 사용
다른 RNN보다 속도가 빠르고 속도에 비해 성능이 좋다
컨브2디와 같이 패딩, 스트라이드 다 가능

DNN
입력 통상적으로 2차원
출력 통상적으로 2차원
model.add(Dense(64, input_shape=(784,)))
(784+1)*64


SimpleRNN
#[batch, timesteps, feature] 3차원
출력 2차원 (return_sequence 쓰면 3차원)
model.add(SimpleRNN(10, input_shape=(5, 1)))
units * (feature + bias + units) = params
(10 * 10) + (1 * 10) + 10 = 120


LSTM
입력 [batch, timesteps, feature] 3차원
입력 [batch, input_length, input_dim]이라고도 명시 가능
출력 2차원 (return_sequence 쓰면 3차원)
model.add(LSTM(10, input_shape=(5, 1)))
4 * units * (feature + bias + units) = params
4 * {(10*10) + (1*10) + 10} = 480
RNN의 4배

GRU
#[batch, timesteps, feature] 3차원
출력 2차원(return_sequence 쓰면 3차원)

model.add(LSTM(10, input_shape=(5, 1)))
3 * units * (feature + bias + units ) = params
3 * {(10*10)+(1*10) + 10} = 360
...정석이지만 최신버전은 bias = 2
이기 때문에
3 * {(10*10) + (1*10) + 10} = 390



시계열 데이터는 y값이 없다.
이미지 데이터도 라벨링 작업을 해야할 때가 있다(y를 만드는 작업)
와인 데이터를 예로 들면, 기본 문제는 퀄리티에 관한 문제였지만
화이트 와인인지, 레드 와인인지 구분하는 문제로 변형할 수도 있다.
이러한 문제들은 개발자가 직업 라벨링 작업을 해주어야한다.
개발자 본인은 timesteps(몇개씩 자를건지) 고민하고,
어떤 데이터를 찾을 것인지 고민해야한다.
split_x도 이중 한가지.


