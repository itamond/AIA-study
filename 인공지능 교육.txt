아나콘다, visual studio code 설치
폴더설정 -> 보기-> 파일 확장명, 숨긴 항목 체크




pip list -  아나콘다 설치 프로그램 버전확인

pip install tensorflow - 텐서플로 설치 

import 포함시켜라

import tensorflow as tf -> 텐서플로를 포함시키는데 tf라고 부를거다.

print(tf.__version__) 텐서플로 버전 출력

import numpy as np - >numpy  라는 글자 형식을 불러옴

x = np.array([1,2,3])  -> x는 1과 2와 3이다 np 형식으로 불러온.

numpy = 인간이 하는 계산과 매우 비슷. 그래서 많이 쓴다.


# = 주석 , 이 코드는 실행시키지 않음. 설명문


"" 따옴표 -> 따옴표 안의 글씨를 그대로 출력

print("a와 b를 더한 값 : ", c)
'-> a와  b를 더한 값 : c 로' 출력



print(x.shape) = 모양을 확인하는 함수. 모델링 전에 많이 사용

optimizer = 최적화

Sequential 모델 =  순차적 모델.

Dense = 이전층의 노드를 다음 층의 모든 노드에 훈련
evaluate= 평가 함수. fit에서 생성된 w 값에 x와 y데이터를 넣어서 판단을 하는것이다
predict= 예측 함수 위에서 []라는 데이터를 넣었으므로 여기서도 []를 넣는다



인공지능은 y = ax + b 이다.
인공지능에서는 wx + b 라고 한다.
w = weight

인공지능은 이 w값을 찾는 것.

인공지능을 학습 시킬때 생기는 오차 (error, loss, cost, 비용, 오차)

최소의  loss를 만드는 것이 인공지능의 궁극의 목적

"최소의 loss를 구해서"->"최적의 weight를 찾는것"

그래프에 선을 긋는 행위(랜덤하게) -> 예측 모델을 만든다.

히든레이어를 가장 효율적으로 찾는 과정
딥러닝은 발명이 아닌 가장 효율적인 히든 레이어를 '발견'하는 과정


"텐서 1에서는 코스트
텐서 2이상부터는 로스"



뉴런= 노드 node

AI > ML > DL


(눈)   - ( 뇌 : 뉴런-뉴런-뉴런-뉴런) - (입에서 침을 흘리다)  (딥러닝의 예제)
input                                      output
 각각의 뉴런마다 y=wx+b 를 했더니 성능이 더 좋다.



반복된 훈련마다
새로운 훈련을 시도할때 w값이 갱신된다(역전파)


이 순서대로 코딩! (AI개발의 진리)
1.데이터  (데이터를 준비하고 깔끔하게정제하는 과정) **가장 힘든일, 가장 중요한 일**
2.모델구성
3.컴파일, 훈련
4.평가, 예측


batch
1,2,3,4,5 를 훈련할때 5번 각각 훈련 -> 1epoch


batch 1이면 1,2,3,4,5 각각 훈련
batch 2이면 12,34,5 로 훈련
batch 3이면 123,45 로 훈련
batch는 developer 재량
batch는 작게 자르면 좋다
그러나 시간이 오래걸린다
batch_size= 핏(fit)에서 수행



행렬


1, 2, 3 이 있을때 각각의 하나의 숫자 = 스칼라 scalar   0차원이다.

[1, 2, 3] 벡터 1차원이다.

[[1, 2, 3]. [ ]]  벡터가 모이면 행렬이라고 한다 metrix 2차원이다.

대괄호 하나당 차원이 하나씩 늘어난다

3차원부터 Tensor 라고 부른다
4차원= 4차원 tensor




1. [[1, 2], [3, 4]]   2X2  2행 2열
2. [[[1, 2, 3]]]   1X1X3  1행 3열자리가 1개
3. [[[1, 2, 3], [4, 5, 6]]]     1X2X3 2행 3열짜리가 1개
4. [[1], [2], [3]]   3X1   3행 1열
5. [[[1]], [[2]], [[3]]]   3X1X1    1행 1열짜리가 3개
6. [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]  2X2X2   2행 2열짜리가 2개
7. [[[1, 2]], [[3, 4]], [[5, 6]], [[7, 8]]]  4X1X2  1행 2열짜리가 4개




1, 2, 3 각각은 스칼라   0차원
[1, 2, 3]    <-벡터는 (3, ) 라고 표시 (3 콤마)   1차원
[[1,2,3,],[4,5,6]] < 행렬  (2, 3)   2차원
x4 => Tensor(4,2,3)    4 바이 2 바이 3   3차원     -> 4 면 2 행 3 렬
x5 => 4차원 Tensor(5,4,2,3) 5바이 4바이 2바이 3



행은 데이터의 갯수, 열은 데이터의 특성★
!!!행무시, 열우선!!!
모델링을 할때 '열의 갯수'를 판단하게 될 것
데이터 (행)을 추가해도 프로그램은 잘 돌아감.


로스를 계산하는 방법
mae = 절대값
mse = 제곱



분류 (남자or여자 같이 0과 1로 구분할 수 있는)

2진분류, 다중분류

회귀 (수치로 나오는)




warning = 경고는 하지만 작동은 한다.   error = 돌아가지 않음